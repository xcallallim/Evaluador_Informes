"""Utilities to locate exported evaluation files.

This module centralises the logic used in notebooks and ad-hoc scripts that
need to inspect the most recent export generated by :class:`EvaluationService`.
Historically these scripts relied on calling ``max()`` over a generator of
``Path.glob`` results.  When the directory was vacío or did not exist the call
raised ``ValueError: max() arg is an empty sequence`` which was not helpful for
analysing the issue.

``find_latest_export`` adds guard rails around the lookup, verifying that the
directory exists and that at least one file matches the requested pattern.
Failing either check triggers an explicit ``FileNotFoundError`` that explains
what went wrong and how to fix it (crear la carpeta o ejecutar primero la
evaluación).
"""

from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, Optional


@dataclass(frozen=True)
class ExportLookup:
    """Result of searching for exported files.

    Attributes
    ----------
    directory:
        Directory that was inspected during the lookup.
    pattern:
        File pattern used in ``Path.glob``.
    matches:
        All the files that matched the pattern ordered by their modification
        time (oldest first).
    latest:
        Convenience reference to the newest file in ``matches``.
    """

    directory: Path
    pattern: str
    matches: tuple[Path, ...]

    @property
    def latest(self) -> Path:
        return self.matches[-1]


class ExportNotFoundError(FileNotFoundError):
    """Specialised exception raised when no exports are available."""


def _validate_directory(directory: Path) -> None:
    if not directory.exists():
        raise ExportNotFoundError(
            f"El directorio '{directory}' no existe. Ejecuta la evaluación "
            "antes de intentar leer los resultados o verifica la ruta."
        )
    if not directory.is_dir():
        raise ExportNotFoundError(
            f"La ruta '{directory}' no es un directorio válido."
        )


def _collect_matches(directory: Path, pattern: str) -> Iterable[Path]:
    return sorted(directory.glob(pattern), key=lambda path: path.stat().st_mtime)


def find_latest_export(
    pattern: str,
    directory: Optional[Path | str] = None,
) -> ExportLookup:
    """Locate the most recent exported file matching ``pattern``.

    Parameters
    ----------
    pattern:
        Glob pattern used to filter the files.  For example,
        ``"resultados_informe_institucional_demo_*.xlsx"``.
    directory:
        Directory where the exported files are stored.  If ``None`` the current
        working directory is used.

    Returns
    -------
    ExportLookup
        Dataclass with the ordered matches and convenience reference to the
        latest file.

    Raises
    ------
    ExportNotFoundError
        If the directory does not exist, is not a directory or the pattern does
        not match any file.
    """

    target_dir = Path(directory) if directory is not None else Path.cwd()
    _validate_directory(target_dir)

    matches = tuple(_collect_matches(target_dir, pattern))
    if not matches:
        raise ExportNotFoundError(
            "No se encontraron archivos que coincidan con "
            f"'{pattern}' en '{target_dir}'. Asegúrate de haber ejecutado "
            "la evaluación o de que el patrón sea correcto."
        )

    return ExportLookup(directory=target_dir, pattern=pattern, matches=matches)


__all__ = [
    "ExportLookup",
    "ExportNotFoundError",
    "find_latest_export",
]